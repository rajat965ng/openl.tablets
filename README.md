

- A **decision table** is a set of rules describing decision situations where the state of a number of conditions determines the execution of a set of actions. It is the basic table type used in OpenL Tablets decision making. 
  - Recent experience shows that in 95% of business cases very simple logic of decision making is used.  To implement such cases just table header, business titles and business data are enough =). If your decision table has the following simple structure: there are conditions for each input parameter of a decision table that check equality of input and condition values, and a return column - go ahead and just use simplified decision table representation!
- A **Lookup table** is a Decision table which contains both vertical and horizontal conditions and returns value on crossroads of matching condition values. 
  - Lookup Table with several horizontal conditions
- A **Simple Data Table**, Using primitive (semi-primitive) Datatypes.
  - You can easily create your own Datatypes in OpenL. They are just simple data holders and are used to quickly prototype your data model without resorting to Java programming. You can use Java beans too (instead of OpenL Datatypes - not recommended - we will show this to you soon).
  -  Notice that for "gender" attribute we use Alias Datatype Gender. Alias Datatype allows you to define possible values for a particular data type. In the example below, the Gende Data type can only be ‘Male’ or ‘Female’.
  -  There might be situation when you need Data Table to have a column with unique values but all defined attribute columns could contain not unique values. In such case you can  insert one more column with predefined _PK_ attribute name (primary key). Moreover, OpenL Tablets validates values of this column on uniqueness.
- **Formulas** in Decision Tables
  - Sometimes you need to enter formulas into Table cells. To do this you need to enter '= before the formula (alternatively, OpenL Tablets code can be enclosed by { }). Formulas have access to Rules input parameters. Calculation result type must match the type of the cell.
- **Column Match Table** has an attached special algorithm (MATCH, SCORE or WEIGHTED) which denotes how the return value is calculated. Let's examine each algorithm separately by examples.
  - MATCH table is designed to map different conditions to a single return value. It takes an argument from the upper row and matches it against condition values from left to right. If they match, the algorithm returns the corresponding return value. If values do not match, the algorithm switches to the next row.
  - SCORE table is designed to calculate total score - the sum of weighted ratings or scores for all matched cases (independent conditions).  It takes an argument from the upper row and matches it against condition values from left to right. When a match is found, the algorithm takes the score value in the corresponding sub column and multiples it by the weight of that row. The product is added to the result sum (total score). After that, the next row is checked. Total score is returned.
  - WEIGHTED table is designed to calculate total score and determine return value by calculated score. It combines SCORE and simple MATCH (with 1 condition) algorithms. The result of SCORE algorithm (total score) is passed to simple Match algorithm as input parameter.
- A **TBasic Table** allows us to implement complex algorithms using several clearly defined structural components (list of some components is described further below). In other words, TBasic Table is a sequential algorithm in a structured user-friendly manner. It supports basic nested looping and branching (WHILE, IF-ELSE, GOTO), subroutines, defining and setting variables.
